{"posts":[{"title":"我的第一篇博客","text":"欢迎来到我的博客！这是我用 Hexo 写的第一篇文章。 关于我我是一名热爱技术的开发者，记录分享是我的习惯。 由于开发技术不胜枚举，因此，作为一名想要不断提升自身的开发者，很有必要记录每一次技术操作以及出现的bug 网上也查找了很多记录blog的办法，感觉依旧是用Hexo与GitHub相结合的方式更加高大上一点点。本人目前最擅长的编程语言是C++，也希望以后可以从事相关C++的开发工作，找到一份很不错的薪资，同时对Python也有所了解，熟悉一些基本的机器学习和深度学习算法。考虑到工作的原因，可能以后还会学习Java。 目前此blog记录的是我的求学生涯之中，做过的所有的开发项目上面遇到的问题以及最后的解决办法。","link":"/2025/05/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"关于 thread 线程和 POSIX 的应用","text":"1. 高精度计时器 POSIX 的使用 一般的应用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;MaxDataWorker.h&quot;#include &quot;max30102.h&quot;#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;thread&gt;#include &lt;signal.h&gt;using namespace std;using namespace chrono;int datacount = 0;void timer_handler(int sig, siginfo_t *si, void *uc){ MAX30102 *data = (MAX30102 *)si-&gt;si_value.sival_ptr; data-&gt;get_data(); datacount++;}MaxDataWorker::MaxDataWorker(QObject *parent, MAX30102 *sensor) : QObject(parent), max30102(sensor){}MaxDataWorker::~MaxDataWorker(){}void MaxDataWorker::doWork(){ struct sigevent sev; struct sigaction sa; sa.sa_flags = SA_SIGINFO; sa.sa_sigaction = timer_handler; sigemptyset(&amp;sa.sa_mask); sigaction(SIGRTMIN, &amp;sa, NULL); sev.sigev_notify = SIGEV_SIGNAL; sev.sigev_signo = SIGRTMIN; sev.sigev_value.sival_ptr = max30102; timer_t timerid; if (timer_create(CLOCK_REALTIME, &amp;sev, &amp;timerid) == -1) { perror(&quot;timer_create&quot;); } struct itimerspec its; its.it_value.tv_sec = 0; its.it_value.tv_nsec = 12500000; its.it_interval.tv_sec = 0; its.it_interval.tv_nsec = 12500000; if (timer_settime(timerid, 0, &amp;its, NULL) == -1) { perror(&quot;timer_settime&quot;); } std::this_thread::sleep_for(std::chrono::seconds(5)); timer_delete(timerid); cout &lt;&lt; &quot;datacount is :&quot; &lt;&lt; datacount &lt;&lt; endl; emit finishRead();} 需要注意的是： sa.sa_sigaction = timer_handler;：只能使用普通函数或静态成员函数。 如果需要访问类成员函数，需通过 sigev_value.sival_ptr 传递对象指针： 123456void timer_handler(int sig, siginfo_t *si, void *uc){ MAX30102 *data = (MAX30102 *)si-&gt;si_value.sival_ptr; data-&gt;get_data(); datacount++;} 1sev.sigev_value.sival_ptr = max30102; POSIX 定时器本身就是一个线程。 2. 关于线程 QThread 和 std::thread可参考：C++ 与 Qt 线程：C++ std::thread 与 Qt QThread 多线程混合编程 3. QThread 与 POSIX 的使用 QThread 与 POSIX 均可用信号机制，不会冲突。 使用 pthread 启动 POSIX 定时器时，可能引发信号干扰，影响其他 QThread 的信号处理。 解决方案：在 MaxPlot.cpp 全局使用 POSIX 定时器，它本身就是线程，可定时触发数据读取逻辑。 4. 多线程竞争与原子操作问题当定时器频繁触发同一方法，若前一次调用未完成，可能导致竞态问题。 可使用 std::atomic 原子操作避免冲突： 123456789101112131415161718192021222324252627282930void MaxPlot::posix_timer_handler(union sigval sv){ MAX30102 *data = static_cast&lt;MAX30102 *&gt;(sv.sival_ptr); bool expected = false; if (data-&gt;is_reading.compare_exchange_strong(expected, true)) { data-&gt;get_data(); data-&gt;datacount++; if (data-&gt;datacount &gt;= 360) { std::cout &lt;&lt; &quot;data is up to full&quot; &lt;&lt; std::endl; data-&gt;datacount = 0; emit data-&gt;finishRead(); data-&gt;Quit(); cout &lt;&lt; &quot;Jump is:&quot; &lt;&lt; data-&gt;count_Jump &lt;&lt; endl; data-&gt;count_Jump = 0; } data-&gt;is_reading = false; } else { std::cerr &lt;&lt; &quot;上一次读取未完成，跳过此次读取&quot; &lt;&lt; std::endl; data-&gt;count_Jump++; data-&gt;datacount++; }}","link":"/2025/05/17/%E5%85%B3%E4%BA%8Ethread%E7%BA%BF%E7%A8%8B%E5%92%8CPOSIX%E7%9A%84%E5%BA%94%E7%94%A8/"},{"title":"关于个人发展的规划","text":"最终目标：拿到大厂的ssp的c++开发岗位的薪资 大方向的计划：1、提升c++代码撰写能力，找c++项目来写，由简到难2、回顾之前学的ACM算法，LeetCode多刷，每天保持刷题3、找实习，从日常实习开始，到大厂实习4、八股文准备（不急） 关于对C++的精进1、精进C++本身，包括STL库以及源码解析，精进进程，线程，多线程，线程池以及之间的调度2、精进Linux系统的使用，Linux多线程服务编程以及MySQL数据库的使用3、精进cuda编程，C++并发编程4、补充关于操作系统，分布式系统的知识 近期打算1、夏令营参加，去psm老师组，目前打算硕士研究生，组里时间自由，尽量提早进组学习，尽快发出论文（CCF-C以上），达到毕业要求，研一期间学习课程的同时，多写写C++项目以及LeetCode刷题，关注实习和就业状况；若是留在xd的lgx老师组里，研一仍然同上，研二干横向锻炼，研二下去实习。2、关于面试的准备： A、PPT发到微信上面，项目准备好说辞，可穿戴皮瓣检测部分，先说嵌入式部分，说清楚板子开发以及多线程操作，以及高精度POSIX定时器和前后端通信协议，然后从用户使用角度介绍QT，接着展示一下前端，最后介绍算法，是商讨之后，提出算法，异常检测检测误差数据，度量学习，详细介绍作分类检测不同皮瓣情况 B、基因压缩部分，说成是算法创新，先是介绍FASTQ文件的碱基和质量分数单独压缩，用算术编码，接着提出联合概率熵比单独编码小，结合两者上下文，详细介绍PPT的手写部分，把上下文预测讲清楚，把尽可能相同的字符放在同一个算术编码器里面压缩，并提及竖着读取文件的想法。再说上这是在实验室主要是干的这两个项目 C、cuda编程部分，先介绍边缘化部署AI模型，接着讲述cuda的CPU与GPU协同工作，异构编程，即CPU处理逻辑，GPU处理计算，同时介绍tensorRT的优化，层融合，RBC（此处要复习一下GPU那些网站的信息），这方面学的不是特别深入；YOLO部分，先介绍YOLO原理（复习之前知乎的资料）大一刚入门AI算法做的不是特别深入，复习问GPT那些图啥意思 D、利用生产实习的时间，温习深度学习算法，考完试之后，复习机器学习和模式识别的知识，同时完善博客，展示博客 2、在这段时间的事情忙完之后（6月中~7月），试下投一下日常实习","link":"/2025/05/17/Plan/"},{"title":"机器学习基础知识总结","text":"本文总结了机器学习中的核心概念、算法分类与应用案例。 Machine_Learning（1）1. 机器学习的分类机器学习主要分为 有监督学习 和 无监督学习 两大类。 有监督学习（Supervised Learning）定义：有监督学习是一种机器学习任务，其中每个训练样本都带有对应的标签（目标值）。模型通过学习这些“输入—输出”对，来预测新数据的输出。 典型任务： 分类（Classification）：预测离散标签，如垃圾邮件识别； 回归（Regression）：预测连续数值，如房价预测。 常见算法及说明： 线性回归（Linear Regression） 用途： 用于预测连续型数值，如房价、温度等。 原理： 建立输入特征与输出变量之间的线性关系模型 模型通过最小化均方误差（MSE）进行拟合。 逻辑回归（Logistic Regression） 用途： 用于二分类问题，输出事件发生的概率。 原理： 先计算线性组合（通过线性函数进行计算），再通过 Sigmoid 函数转换为概率。 支持向量机（SVM） 用途： 用于分类或回归，在高维空间中表现良好。 原理： SVM（支持向量机）是一种监督学习方法，其原理是通过在特征空间中构造一个最优超平面，将不同类别的样本最大间隔地分开，以提高模型的泛化能力；对于不可线性可分的情况，SVM通过核函数将数据映射到高维空间，使其在高维空间中线性可分，从而实现非线性分类。 K近邻（KNN） 用途： 用于分类与回归，基于样本相似度做预测。 原理： KNN（K-近邻算法）是一种基于距离度量的监督学习方法，其核心思想是：对一个待分类或预测的样本，给定已有的标记样本，找到训练集中距离它最近的K个样本，根据这些邻居的多数类别（投票）（分类）或平均数值（回归）来决定该样本的预测结果。 无监督学习（Unsupervised Learning）定义：无监督学习是一种机器学习任务，其中训练数据没有标签，模型需要自行发现数据中的模式、结构或分布。 典型任务： 聚类（Clustering）：将数据分成相似的组。 降维（Dimensionality Reduction）：压缩数据特征，减少冗余。 常见算法及说明： K-Means 聚类 用途： 用于将样本自动划分为预设的 K 个簇（类），常用于客户分群、图像分割等。 原理： 随机初始化 K 个聚类中心，然后迭代以下两个步骤直到收敛： 将每个样本分配给距离其最近的中心点； 更新每个簇的中心点为簇内所有样本的平均值。 特点： 简单高效，适用于大规模数据； 必须提前指定聚类数 K； 对初始中心敏感，可能陷入局部最优。 层次聚类（Hierarchical Clustering） 用途： 通过构建一个聚类的层次结构，实现自顶向下或自底向上的聚类，可视化强。 原理： 自底向上（凝聚型）：每个点开始作为一个单独簇，逐步合并最近的簇； 自顶向下（分裂型）：从一个整体出发，逐步分裂成更小的簇。 最终结果通常以树状图（Dendrogram）方式展示，可观察不同聚类层级。 特点： 不需要提前指定 K 值； 可生成多层次结构； 计算复杂度较高，不适合超大数据集。 主成分分析（PCA, Principal Component Analysis） 用途： 用于降维，压缩特征空间同时保留数据的主要信息，常用于可视化和特征提取。 原理： 通过线性变换找到一组新的正交坐标轴（主成分）； 第一个主成分具有最大方差，第二个主成分与第一个正交，且具有次大方差，依此类推； 最终保留前 K 个主成分，用于表示数据。 特点： 降维效果好，计算效率高； 可去除特征冗余、提高模型泛化能力； 属于线性方法，难以处理非线性特征关系。 2. 应用实例对比 类别 应用示例 输入数据类型 输出结果 有监督学习 邮件分类 邮件内容（文本） 是否为垃圾邮件 有监督学习 房价预测 房屋面积、地段等 房价（连续值） 无监督学习 客户分群 用户购买记录、访问频率 用户分类 无监督学习 图像降维 像素矩阵 降维后向量表示 3. 总结 有监督学习 适合解决“有标签”的任务，如分类与回归； 无监督学习 更注重发现数据内部结构； 掌握它们的区别，有助于我们在实际场景中选择合适的算法。","link":"/2025/05/18/Machine_Learning(1)/"},{"title":"Git 本地版本管理操作教程","text":"本文介绍 Git 的基础安装与常见本地版本管理操作流程，包括克隆仓库、提交、分支管理等。 1. 安装 Git下载安装 Git 官网 提供的安装包，按提示安装。 2. 配置 Git 用户信息git config –global user.name “你的用户名”git config –global user.email “你的邮箱” 3、创建或者克隆仓库用于保存版本克隆仓库mkdir my_projectcd my_projectgit init 保存版本 git clone https://github.com//username/project.git 4、把需要进行版本管理的文件添加到仓库 git add filename git add . 5、提交更改 git commit -m &quot;commit message&quot; 6、查看状态和提交历史 git status (查看提交状态) git log（查看提交历史） 7、分支管理 git branch new-branch-name git checkout new-branch-name(切换到指定分支) git checkout main(回到main分支) git merge new-branch-name(合并分支) 8、添加远程仓库git remote add origin https://github.com/username/rep.git git push origin main(推送更改到远程仓库) 9、回溯版本 git log git check abc1234(找到回溯ID) git checkout main(回到最新状态) 10、其余操作 git diff(查看未提交的更改) git branch new-feature(开发分支) 通过以上操作，可以在本地进行版本管理，随时进行代码的回溯与更新！","link":"/2025/05/18/git%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"title":"利用 qmake 构建 Qt 项目与开发过程细节说明","text":"本文介绍使用 qmake 构建 Qt 应用程序的标准流程，并附带一个 .pro 文件的示例。同时说明了开发过程中在逻辑设计上的注意事项。 1. 利用 qmake 进行 Qt 项目编译Qt 提供的 qmake 工具可以自动根据 .pro 文件生成 Makefile 文件，从而简化项目的构建流程。 构建步骤：1234qmake # 生成 Makefilemake # 执行编译./MyApplication # 运行程序 .pro文件配置如下#————————————————-# Project created by QtCreator#————————————————- 指定项目模板类型，可为 app（应用程序）、lib（库）等TEMPLATE = app 生成的目标可执行文件名称TARGET = MyApplication 使用的 Qt 模块QT += core gui QT += widgets # 如使用 QWidget 可启用编译器配置CONFIG += c++17 console 源文件列表SOURCES += main.cpp mainwindow.cpp 头文件列表HEADERS += mainwindow.h UI 界面文件（来自 Qt Designer）FORMS += mainwindow.ui 资源文件（可选）RESOURCES += resources.qrc外部包含路径与库INCLUDEPATH += /path/to/includesLIBS += -L/path/to/libs -lname 编译宏定义DEFINES += QT_DEPRECATED_WARNINGS 输出目录与中间目录配置DESTDIR = binOBJECTS_DIR = build/objMOC_DIR = build/mocRCC_DIR = build/rccUI_DIR = build/ui 完整示例：12345678910111213141516171819202122232425262728293031323334353637DESTDIR = ./build/binOBJECTS_DIR = ./build/objMOC_DIR = ./build/mocRCC_DIR = ./build/rccUI_DIR = ./build/uiQT += core gui concurrentgreaterThan(QT_MAJOR_VERSION, 4): QT += widgets printsupportgreaterThan(QT_MAJOR_VERSION, 4): CONFIG += c++11lessThan(QT_MAJOR_VERSION, 5): QMAKE_CXXFLAGS += -std=c++11LIBS += -L/lib/aarch64-linux-gnu -lcurlLIBS += -L/lib/aarch64-linux-gnu -lpaho-mqtt3cLIBS += -L/lib/aarch64-linux-gnu -lqrencodeLIBS += -L/lib/aarch64-linux-gnu -lpngTARGET = collectTEMPLATE = appSOURCES += main.cpp\\ mainwindow.cpp\\ qcustomplot.cpp\\ max30102.cpp\\ MaxPlot.cpp \\ MQTTWorker.cpp\\ QRCodeGenerator.cpp HEADERS += qcustomplot.h\\ mainwindow.h\\ MaxPlot.h\\ max30102.h \\ MQTTWorker.h \\ QRCodeGenerator.h 开发过程中的细节考虑：在Qt的mainwindow.cpp文件里面，不可出现扫描通道的代码，原因是，在用户层面不需要考虑扫描通道的问题，只需要得到数据。","link":"/2025/05/18/Linux%E4%B8%8B%E7%9A%84QT%E8%AE%BE%E8%AE%A1/"},{"title":"MAX30102 多通道 I2C 通讯与初始化问题分析","text":"本文记录在多通道 I2C 通讯过程中使用 MAX30102 传感器时遇到的问题及解决方案，适合用于多通道血氧模块或多传感器项目参考。 ==1. 通道选择问题：==通过 write(sensor, &amp;channel, 1) 来进行通道的选取和切换，但仅限于存在设备的通道可以正常扫描和初始化传感器。 问题原因：由于 write() 具有阻塞作用，当扫描到一个无设备的通道时会卡死，导致无法继续后续通道扫描。 解决思路：借助 Linux 系统自带的 i2ctools 工具进行通道扫描，使用如下命令： i2cset -y 4 0x70 0x01 i2cdetect -y 4 代码分享1234567891011121314151617181920212223242526272829303132void MAX30102::scanf_channel(){ for (int i = 0; i &lt; 8; i++) { char command[128]; snprintf(command, sizeof(command), &quot;i2cset -y 4 0x%02x 0x00 0x%02x&quot;, TCA9548A_ADDR, 1 &lt;&lt; i); if (system(command) != 0) { continue; } char detect_command[128]; snprintf(detect_command, sizeof(detect_command), &quot;i2cdetect -y 4 | grep -q '57'&quot;); if (system(detect_command) == 0) { enable_channels[count_channel++] = i; } else { std::cerr &lt;&lt; &quot;No device found at address 0x57 on channel &quot; &lt;&lt; std::endl; continue; } } for (int i = 0; i &lt; count_channel; i++) { std::cout &lt;&lt; &quot;channel : &quot; &lt;&lt; enable_channels[i] &lt;&lt; std::endl; }} ==2. 关于 I2C 总线设置问题：==2.1 通信频率与打开限制 I2C 总线最大频率为 400kHz； I2C 设备 不允许频繁重复打开； 否则会报错或导致设备失效(总线错误)。 2.2 通道切换与设备切换失败问题问题：切换了通道但设备没有跟随切换，原因是 write() 函数阻塞，导致 I2C 指向未切换成功的设备节点。 解决方法：先统一打开一次 I2C 总线，在实际访问设备时，动态返回配置后的设备句柄，并在使用后手动关闭以避免资源冲突。 示例代码：1234567891011121314151617int MAX30102::init_i2c(const char *device, int addr){ int temp_fd = open(device, O_RDWR); if (temp_fd == -1) { perror(&quot;Failed to open I2C device&quot;); return -1; } if (ioctl(temp_fd, I2C_SLAVE, addr) &lt; 0) { perror(&quot;Failed to set I2C address&quot;); close(temp_fd); return -1; } return temp_fd;}","link":"/2024/11/18/Linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91-max30102_tca9548/"},{"title":"MQTT 与 HTTP 通信协议对比及项目应用场景选择","text":"本文总结了 MQTT 与 HTTP 协议的区别、各自的适用场景，并结合项目案例说明了前后端通信选型理由。 ==1. MQTT 通信与网络协议==相关学习资料： MQTT协议详解(完整版) - CSDN博客 MQTT协议史上最全解析 - CSDN博客 TCP/IP协议图解 - CSDN博客 HTTP协议详解 - CSDN博客 MQTT 示例代码（C）：1234567891011121314151617181920MQTTClient client;MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;MQTTClient_create(&amp;client, ADDRESS, CLIENTID, MQTTCLIENT_PERSISTENCE_NONE, NULL);int rc;if ((rc = MQTTClient_connect(client, &amp;conn_opts)) != MQTTCLIENT_SUCCESS){ printf(&quot;Failed to connect, return code %d\\n&quot;, rc); exit(EXIT_FAILURE);}char payload[100];sprintf(payload, &quot;Middle Data : %u, %u&quot;, red_data, ir_data);MQTTClient_message pubmsg = MQTTClient_message_initializer;pubmsg.payload = payload;pubmsg.payloadlen = strlen(payload);pubmsg.qos = QOS;pubmsg.retained = 0;MQTTClient_deliveryToken token;MQTTClient_publishMessage(client, TOPIC, &amp;pubmsg, &amp;token);MQTTClient_waitForCompletion(client, token, TIMEOUT);printf(&quot;Message with delivery token %d delivered\\n&quot;, token); 2.前后端交互(API)的使用 什么是API： API（应用程序编程接口，Application Programming Interface）是一组定义不同软件组件之间如何相互通信和交互的规范和协议。API 充当了不同软件系统之间的桥梁，使它们能够无缝协作，而无需了解彼此的内部实现细节。 如何理解API，API 是如何工作的-CSDN博客 3.HTTP和MQTT的选择要区分什么时候使用MQTT，什么时候使用HTTP，我们需要弄清楚两者的本质和适用情况： MQTT是长连接的，本质上是发布/订阅（Pub/Sub）消息传输协议，专门设计用于低带宽、不稳定网络环境中的物联网（IoT）应用。它基于TCP/IP协议，支持高效的消息传递。 MQTT通过持久连接（保持连接）进行通信。客户端与消息代理建立长连接，在整个会话过程中保持连接，这样可以在连接断开时恢复并继续接收消息。MQTT为了减少带宽消耗，MQTT的消息头非常小，适合低带宽、高延迟的网络环境。它支持消息的质量服务（QoS）级别，确保消息传递的可靠性。 HTTP是一种请求/响应（Request/Response）协议，主要用于Web通信，基于客户端-服务器模型。HTTP通常用于浏览器与服务器之间的数据交换。HTTP每次请求都会建立一个新的连接（虽然现代HTTP（如HTTP/2）支持连接复用）。HTTP的连接通常在请求完成后关闭。HTTP的消息头较大，适合传输结构化的数据（如HTML、JSON等），但在低带宽环境下可能表现不佳。 在本次项目里面，采集前端和后端的数据传输使用HTTP而不是MQTT，因为我们需要对数据进行打包处理，即把一次(读一段时间的数据)打包发送到后端，这样处理，方便后续的数据处理与分类。处理的数据以JSON格式发送，更适合HTTP的方式。同时具有更强的鲁棒性，可以自行控制采集的时间以及发送的时间，而且采用HTTP的请求/响应模式，后端可以给采集前端发送是否接受到数据的信息，即采集前端可以知道数据传输情况，以便数据丢失的情况下可以在采集前端进行再次发送。同时因为MQTT只是发布/订阅模式，这样采集前端就只是发布数据，至于后端的订阅有没有出问题，采集前端不好直接判断出来。同时考虑到MQTT具有较强的实时性，在此处也并不需要，因为只需要保证数据采集回来就行，所以采用MQTT会增加网络处理的压力。","link":"/2025/05/19/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"POSIX","slug":"POSIX","link":"/tags/POSIX/"},{"name":"QThread","slug":"QThread","link":"/tags/QThread/"},{"name":"个人规划","slug":"个人规划","link":"/tags/%E4%B8%AA%E4%BA%BA%E8%A7%84%E5%88%92/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"版本控制","slug":"版本控制","link":"/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"Qt","slug":"Qt","link":"/tags/Qt/"},{"name":"qmake","slug":"qmake","link":"/tags/qmake/"},{"name":"MAX30102","slug":"MAX30102","link":"/tags/MAX30102/"},{"name":"I2C","slug":"I2C","link":"/tags/I2C/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"嵌入式开发","slug":"嵌入式开发","link":"/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"},{"name":"MQTT","slug":"MQTT","link":"/tags/MQTT/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"网络通信","slug":"网络通信","link":"/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"categories":[{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"技术分享","slug":"技术分享","link":"/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"个人介绍","slug":"个人介绍","link":"/categories/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"}],"pages":[]}