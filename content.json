{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/05/15/hello-world/"},{"title":"我的第一篇博客","text":"欢迎来到我的博客！这是我用 Hexo 写的第一篇文章。 关于我我是一名热爱技术的开发者，记录分享是我的习惯。 由于开发技术不胜枚举，因此，作为一名想要不断提升自身的开发者，很有必要记录每一次技术操作以及出现的bug 网上也查找了很多记录blog的办法，感觉依旧是用Hexo与GitHub相结合的方式更加高大上一点点。本人目前最擅长的编程语言是C++，也希望以后可以从事相关C++的开发工作，找到一份很不错的薪资，同时对Python也有所了解，熟悉一些基本的机器学习和深度学习算法。考虑到工作的原因，可能以后还会学习Java。 目前此blog记录的是我的求学生涯之中，做过的所有的开发项目上面遇到的问题以及最后的解决办法。","link":"/2025/05/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"关于 thread 线程和 POSIX 的应用","text":"1. 高精度计时器 POSIX 的使用 一般的应用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;MaxDataWorker.h&quot;#include &quot;max30102.h&quot;#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;thread&gt;#include &lt;signal.h&gt;using namespace std;using namespace chrono;int datacount = 0;void timer_handler(int sig, siginfo_t *si, void *uc){ MAX30102 *data = (MAX30102 *)si-&gt;si_value.sival_ptr; data-&gt;get_data(); datacount++;}MaxDataWorker::MaxDataWorker(QObject *parent, MAX30102 *sensor) : QObject(parent), max30102(sensor){}MaxDataWorker::~MaxDataWorker(){}void MaxDataWorker::doWork(){ struct sigevent sev; struct sigaction sa; sa.sa_flags = SA_SIGINFO; sa.sa_sigaction = timer_handler; sigemptyset(&amp;sa.sa_mask); sigaction(SIGRTMIN, &amp;sa, NULL); sev.sigev_notify = SIGEV_SIGNAL; sev.sigev_signo = SIGRTMIN; sev.sigev_value.sival_ptr = max30102; timer_t timerid; if (timer_create(CLOCK_REALTIME, &amp;sev, &amp;timerid) == -1) { perror(&quot;timer_create&quot;); } struct itimerspec its; its.it_value.tv_sec = 0; its.it_value.tv_nsec = 12500000; its.it_interval.tv_sec = 0; its.it_interval.tv_nsec = 12500000; if (timer_settime(timerid, 0, &amp;its, NULL) == -1) { perror(&quot;timer_settime&quot;); } std::this_thread::sleep_for(std::chrono::seconds(5)); timer_delete(timerid); cout &lt;&lt; &quot;datacount is :&quot; &lt;&lt; datacount &lt;&lt; endl; emit finishRead();} 需要注意的是： sa.sa_sigaction = timer_handler;：只能使用普通函数或静态成员函数。 如果需要访问类成员函数，需通过 sigev_value.sival_ptr 传递对象指针： 123456void timer_handler(int sig, siginfo_t *si, void *uc){ MAX30102 *data = (MAX30102 *)si-&gt;si_value.sival_ptr; data-&gt;get_data(); datacount++;} 1sev.sigev_value.sival_ptr = max30102; POSIX 定时器本身就是一个线程。 2. 关于线程 QThread 和 std::thread可参考：C++ 与 Qt 线程：C++ std::thread 与 Qt QThread 多线程混合编程 3. QThread 与 POSIX 的使用 QThread 与 POSIX 均可用信号机制，不会冲突。 使用 pthread 启动 POSIX 定时器时，可能引发信号干扰，影响其他 QThread 的信号处理。 解决方案：在 MaxPlot.cpp 全局使用 POSIX 定时器，它本身就是线程，可定时触发数据读取逻辑。 4. 多线程竞争与原子操作问题当定时器频繁触发同一方法，若前一次调用未完成，可能导致竞态问题。 可使用 std::atomic 原子操作避免冲突： 123456789101112131415161718192021222324252627282930void MaxPlot::posix_timer_handler(union sigval sv){ MAX30102 *data = static_cast&lt;MAX30102 *&gt;(sv.sival_ptr); bool expected = false; if (data-&gt;is_reading.compare_exchange_strong(expected, true)) { data-&gt;get_data(); data-&gt;datacount++; if (data-&gt;datacount &gt;= 360) { std::cout &lt;&lt; &quot;data is up to full&quot; &lt;&lt; std::endl; data-&gt;datacount = 0; emit data-&gt;finishRead(); data-&gt;Quit(); cout &lt;&lt; &quot;Jump is:&quot; &lt;&lt; data-&gt;count_Jump &lt;&lt; endl; data-&gt;count_Jump = 0; } data-&gt;is_reading = false; } else { std::cerr &lt;&lt; &quot;上一次读取未完成，跳过此次读取&quot; &lt;&lt; std::endl; data-&gt;count_Jump++; data-&gt;datacount++; }}","link":"/2025/05/17/%E5%85%B3%E4%BA%8Ethread%E7%BA%BF%E7%A8%8B%E5%92%8CPOSIX%E7%9A%84%E5%BA%94%E7%94%A8/"},{"title":"关于个人发展的规划","text":"最终目标：拿到大厂的ssp的c++开发岗位的薪资 大方向的计划：1、提升c++代码撰写能力，找c++项目来写，由简到难2、回顾之前学的ACM算法，LeetCode多刷，每天保持刷题3、找实习，从日常实习开始，到大厂实习4、八股文准备（不急） 关于对C++的精进1、精进C++本身，包括STL库以及源码解析，精进进程，线程，多线程，线程池以及之间的调度2、精进Linux系统的使用，Linux多线程服务编程以及MySQL数据库的使用3、精进cuda编程，C++并发编程4、补充关于操作系统，分布式系统的知识 近期打算1、夏令营参加，去psm老师组，目前打算硕士研究生，组里时间自由，尽量提早进组学习，尽快发出论文（CCF-C以上），达到毕业要求，研一期间学习课程的同时，多写写C++项目以及LeetCode刷题，关注实习和就业状况；若是留在xd的lgx老师组里，研一仍然同上，研二干横向锻炼，研二下去实习。2、关于面试的准备： A、PPT发到微信上面，项目准备好说辞，可穿戴皮瓣检测部分，先说嵌入式部分，说清楚板子开发以及多线程操作，以及高精度POSIX定时器和前后端通信协议，然后从用户使用角度介绍QT，接着展示一下前端，最后介绍算法，是商讨之后，提出算法，异常检测检测误差数据，度量学习，详细介绍作分类检测不同皮瓣情况 B、基因压缩部分，说成是算法创新，先是介绍FASTQ文件的碱基和质量分数单独压缩，用算术编码，接着提出联合概率熵比单独编码小，结合两者上下文，详细介绍PPT的手写部分，把上下文预测讲清楚，把尽可能相同的字符放在同一个算术编码器里面压缩，并提及竖着读取文件的想法。再说上这是在实验室主要是干的这两个项目 C、cuda编程部分，先介绍边缘化部署AI模型，接着讲述cuda的CPU与GPU协同工作，异构编程，即CPU处理逻辑，GPU处理计算，同时介绍tensorRT的优化，层融合，RBC（此处要复习一下GPU那些网站的信息），这方面学的不是特别深入；YOLO部分，先介绍YOLO原理（复习之前知乎的资料）大一刚入门AI算法做的不是特别深入，复习问GPT那些图啥意思 D、利用生产实习的时间，温习深度学习算法，考完试之后，复习机器学习和模式识别的知识，同时完善博客，展示博客 2、在这段时间的事情忙完之后（6月中~7月），试下投一下日常实习","link":"/2025/05/17/Plan/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"POSIX","slug":"POSIX","link":"/tags/POSIX/"},{"name":"QThread","slug":"QThread","link":"/tags/QThread/"},{"name":"个人规划","slug":"个人规划","link":"/tags/%E4%B8%AA%E4%BA%BA%E8%A7%84%E5%88%92/"}],"categories":[{"name":"技术分享","slug":"技术分享","link":"/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"个人介绍","slug":"个人介绍","link":"/categories/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"}],"pages":[]}