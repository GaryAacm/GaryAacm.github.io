{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2025/05/15/hello-world/"},{"title":"我的第一篇博客","text":"欢迎来到我的博客！这是我用 Hexo 写的第一篇文章。 关于我我是一名热爱技术的开发者，记录分享是我的习惯。 由于开发技术不胜枚举，因此，作为一名想要不断提升自身的开发者，很有必要记录每一次技术操作以及出现的bug 网上也查找了很多记录blog的办法，感觉依旧是用Hexo与GitHub相结合的方式更加高大上一点点。本人目前最擅长的编程语言是C++，也希望以后可以从事相关C++的开发工作，找到一份很不错的薪资，同时对Python也有所了解，熟悉一些基本的机器学习和深度学习算法。考虑到工作的原因，可能以后还会学习Java。 目前此blog记录的是我的求学生涯之中，做过的所有的开发项目上面遇到的问题以及最后的解决办法。","link":"/2025/05/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"关于 thread 线程和 POSIX 的应用","text":"1. 高精度计时器 POSIX 的使用 一般的应用：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &quot;MaxDataWorker.h&quot;#include &quot;max30102.h&quot;#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;thread&gt;#include &lt;signal.h&gt;using namespace std;using namespace chrono;int datacount = 0;void timer_handler(int sig, siginfo_t *si, void *uc){ MAX30102 *data = (MAX30102 *)si-&gt;si_value.sival_ptr; data-&gt;get_data(); datacount++;}MaxDataWorker::MaxDataWorker(QObject *parent, MAX30102 *sensor) : QObject(parent), max30102(sensor){}MaxDataWorker::~MaxDataWorker(){}void MaxDataWorker::doWork(){ struct sigevent sev; struct sigaction sa; sa.sa_flags = SA_SIGINFO; sa.sa_sigaction = timer_handler; sigemptyset(&amp;sa.sa_mask); sigaction(SIGRTMIN, &amp;sa, NULL); sev.sigev_notify = SIGEV_SIGNAL; sev.sigev_signo = SIGRTMIN; sev.sigev_value.sival_ptr = max30102; timer_t timerid; if (timer_create(CLOCK_REALTIME, &amp;sev, &amp;timerid) == -1) { perror(&quot;timer_create&quot;); } struct itimerspec its; its.it_value.tv_sec = 0; its.it_value.tv_nsec = 12500000; its.it_interval.tv_sec = 0; its.it_interval.tv_nsec = 12500000; if (timer_settime(timerid, 0, &amp;its, NULL) == -1) { perror(&quot;timer_settime&quot;); } std::this_thread::sleep_for(std::chrono::seconds(5)); timer_delete(timerid); cout &lt;&lt; &quot;datacount is :&quot; &lt;&lt; datacount &lt;&lt; endl; emit finishRead();} 需要注意的是： sa.sa_sigaction = timer_handler;：只能使用普通函数或静态成员函数。 如果需要访问类成员函数，需通过 sigev_value.sival_ptr 传递对象指针： 123456void timer_handler(int sig, siginfo_t *si, void *uc){ MAX30102 *data = (MAX30102 *)si-&gt;si_value.sival_ptr; data-&gt;get_data(); datacount++;} 1sev.sigev_value.sival_ptr = max30102; POSIX 定时器本身就是一个线程。 2. 关于线程 QThread 和 std::thread可参考：C++ 与 Qt 线程：C++ std::thread 与 Qt QThread 多线程混合编程 3. QThread 与 POSIX 的使用 QThread 与 POSIX 均可用信号机制，不会冲突。 使用 pthread 启动 POSIX 定时器时，可能引发信号干扰，影响其他 QThread 的信号处理。 解决方案：在 MaxPlot.cpp 全局使用 POSIX 定时器，它本身就是线程，可定时触发数据读取逻辑。 4. 多线程竞争与原子操作问题当定时器频繁触发同一方法，若前一次调用未完成，可能导致竞态问题。 可使用 std::atomic 原子操作避免冲突： 123456789101112131415161718192021222324252627282930void MaxPlot::posix_timer_handler(union sigval sv){ MAX30102 *data = static_cast&lt;MAX30102 *&gt;(sv.sival_ptr); bool expected = false; if (data-&gt;is_reading.compare_exchange_strong(expected, true)) { data-&gt;get_data(); data-&gt;datacount++; if (data-&gt;datacount &gt;= 360) { std::cout &lt;&lt; &quot;data is up to full&quot; &lt;&lt; std::endl; data-&gt;datacount = 0; emit data-&gt;finishRead(); data-&gt;Quit(); cout &lt;&lt; &quot;Jump is:&quot; &lt;&lt; data-&gt;count_Jump &lt;&lt; endl; data-&gt;count_Jump = 0; } data-&gt;is_reading = false; } else { std::cerr &lt;&lt; &quot;上一次读取未完成，跳过此次读取&quot; &lt;&lt; std::endl; data-&gt;count_Jump++; data-&gt;datacount++; }}","link":"/2025/05/17/%E5%85%B3%E4%BA%8Ethread%E7%BA%BF%E7%A8%8B%E5%92%8CPOSIX%E7%9A%84%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"博客搭建","slug":"博客搭建","link":"/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"POSIX","slug":"POSIX","link":"/tags/POSIX/"},{"name":"QThread","slug":"QThread","link":"/tags/QThread/"}],"categories":[{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"技术分享","slug":"技术分享","link":"/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"pages":[]}